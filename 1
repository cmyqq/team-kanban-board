export function initDragDrop() {
    document.querySelectorAll('.task-card').forEach(card => {
        card.setAttribute('draggable', true);
        card.addEventListener('dragstart', handleDragStart);
    });
    document.querySelectorAll('.kanban-column').forEach(column => {
        column.addEventListener('dragover', handleDragOver);
        column.addEventListener('drop', handleDrop);
    });
}
let draggedTaskId = null;
function handleDragStart(e) {
    draggedTaskId = this.dataset.taskId;
    this.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
}
function handleDragOver(e) {
    e.preventDefault();
    this.classList.add('drag-over');
}
function handleDrop(e) {
    e.preventDefault();
    this.classList.remove('drag-over');
    if (!draggedTaskId) return;
    const targetStatus = this.dataset.status;
    updateTaskStatus(draggedTaskId, targetStatus);
    const draggedCard = document.querySelector(`[data-task-id="${draggedTaskId}"]`);
    draggedCard.classList.remove('dragging');
    this.querySelector('.task-list').appendChild(draggedCard);
}
function updateTaskStatus(taskId, newStatus) {
    const tasks = JSON.parse(localStorage.getItem('kanbanTasks')) || [];
    const updatedTasks = tasks.map(task => 
        task.id === taskId ? { ...task, status: newStatus } : task
    );
    localStorage.setItem('kanbanTasks', JSON.stringify(updatedTasks));
}
document.addEventListener('DOMContentLoaded', initDragDrop);
